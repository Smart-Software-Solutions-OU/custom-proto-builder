// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SwapAmountInRoute {
    #[prost(uint64, tag = "1")]
    pub pool_id: u64,
    #[prost(string, tag = "2")]
    pub token_out_denom: ::prost::alloc::string::String,
}
impl ::prost::Name for SwapAmountInRoute {
    const NAME: &'static str = "SwapAmountInRoute";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.SwapAmountInRoute".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.SwapAmountInRoute".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SwapAmountOutRoute {
    #[prost(uint64, tag = "1")]
    pub pool_id: u64,
    #[prost(string, tag = "2")]
    pub token_in_denom: ::prost::alloc::string::String,
}
impl ::prost::Name for SwapAmountOutRoute {
    const NAME: &'static str = "SwapAmountOutRoute";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.SwapAmountOutRoute".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.SwapAmountOutRoute".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SwapAmountInSplitRoute {
    #[prost(message, repeated, tag = "1")]
    pub pools: ::prost::alloc::vec::Vec<SwapAmountInRoute>,
    #[prost(string, tag = "2")]
    pub token_in_amount: ::prost::alloc::string::String,
}
impl ::prost::Name for SwapAmountInSplitRoute {
    const NAME: &'static str = "SwapAmountInSplitRoute";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.SwapAmountInSplitRoute".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.SwapAmountInSplitRoute".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SwapAmountOutSplitRoute {
    #[prost(message, repeated, tag = "1")]
    pub pools: ::prost::alloc::vec::Vec<SwapAmountOutRoute>,
    #[prost(string, tag = "2")]
    pub token_out_amount: ::prost::alloc::string::String,
}
impl ::prost::Name for SwapAmountOutSplitRoute {
    const NAME: &'static str = "SwapAmountOutSplitRoute";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.SwapAmountOutSplitRoute".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.SwapAmountOutSplitRoute".into()
    }
}
/// ModuleRouter defines a route encapsulating pool type.
/// It is used as the value of a mapping from pool id to the pool type,
/// allowing the pool manager to know which module to route swaps to given the
/// pool id.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleRoute {
    /// pool_type specifies the type of the pool
    #[prost(enumeration = "PoolType", tag = "1")]
    pub pool_type: i32,
    #[prost(uint64, tag = "2")]
    pub pool_id: u64,
}
impl ::prost::Name for ModuleRoute {
    const NAME: &'static str = "ModuleRoute";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.ModuleRoute".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.ModuleRoute".into()
    }
}
/// PoolType is an enumeration of all supported pool types.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PoolType {
    /// Balancer is the standard xy=k curve. Its pool model is defined in x/gamm.
    Balancer = 0,
    /// Stableswap is the Solidly cfmm stable swap curve. Its pool model is defined
    /// in x/gamm.
    Stableswap = 1,
    /// Concentrated is the pool model specific to concentrated liquidity. It is
    /// defined in x/concentrated-liquidity.
    Concentrated = 2,
    /// CosmWasm is the pool model specific to CosmWasm. It is defined in
    /// x/cosmwasmpool.
    CosmWasm = 3,
}
impl PoolType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PoolType::Balancer => "Balancer",
            PoolType::Stableswap => "Stableswap",
            PoolType::Concentrated => "Concentrated",
            PoolType::CosmWasm => "CosmWasm",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Balancer" => Some(Self::Balancer),
            "Stableswap" => Some(Self::Stableswap),
            "Concentrated" => Some(Self::Concentrated),
            "CosmWasm" => Some(Self::CosmWasm),
            _ => None,
        }
    }
}
/// ===================== MsgSwapExactAmountIn
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgSwapExactAmountIn {
    #[prost(string, tag = "1")]
    pub sender: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub routes: ::prost::alloc::vec::Vec<SwapAmountInRoute>,
    #[prost(message, optional, tag = "3")]
    pub token_in: ::core::option::Option<
        super::super::super::cosmos::base::v1beta1::Coin,
    >,
    #[prost(string, tag = "4")]
    pub token_out_min_amount: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgSwapExactAmountIn {
    const NAME: &'static str = "MsgSwapExactAmountIn";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.MsgSwapExactAmountIn".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.MsgSwapExactAmountIn".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgSwapExactAmountInResponse {
    #[prost(string, tag = "1")]
    pub token_out_amount: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgSwapExactAmountInResponse {
    const NAME: &'static str = "MsgSwapExactAmountInResponse";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.MsgSwapExactAmountInResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.MsgSwapExactAmountInResponse".into()
    }
}
/// ===================== MsgSplitRouteSwapExactAmountIn
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgSplitRouteSwapExactAmountIn {
    #[prost(string, tag = "1")]
    pub sender: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub routes: ::prost::alloc::vec::Vec<SwapAmountInSplitRoute>,
    #[prost(string, tag = "3")]
    pub token_in_denom: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub token_out_min_amount: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgSplitRouteSwapExactAmountIn {
    const NAME: &'static str = "MsgSplitRouteSwapExactAmountIn";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.MsgSplitRouteSwapExactAmountIn".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.MsgSplitRouteSwapExactAmountIn".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgSplitRouteSwapExactAmountInResponse {
    #[prost(string, tag = "1")]
    pub token_out_amount: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgSplitRouteSwapExactAmountInResponse {
    const NAME: &'static str = "MsgSplitRouteSwapExactAmountInResponse";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.MsgSplitRouteSwapExactAmountInResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.MsgSplitRouteSwapExactAmountInResponse".into()
    }
}
/// ===================== MsgSwapExactAmountOut
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgSwapExactAmountOut {
    #[prost(string, tag = "1")]
    pub sender: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub routes: ::prost::alloc::vec::Vec<SwapAmountOutRoute>,
    #[prost(string, tag = "3")]
    pub token_in_max_amount: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub token_out: ::core::option::Option<
        super::super::super::cosmos::base::v1beta1::Coin,
    >,
}
impl ::prost::Name for MsgSwapExactAmountOut {
    const NAME: &'static str = "MsgSwapExactAmountOut";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.MsgSwapExactAmountOut".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.MsgSwapExactAmountOut".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgSwapExactAmountOutResponse {
    #[prost(string, tag = "1")]
    pub token_in_amount: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgSwapExactAmountOutResponse {
    const NAME: &'static str = "MsgSwapExactAmountOutResponse";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.MsgSwapExactAmountOutResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.MsgSwapExactAmountOutResponse".into()
    }
}
/// ===================== MsgSplitRouteSwapExactAmountOut
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgSplitRouteSwapExactAmountOut {
    #[prost(string, tag = "1")]
    pub sender: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub routes: ::prost::alloc::vec::Vec<SwapAmountOutSplitRoute>,
    #[prost(string, tag = "3")]
    pub token_out_denom: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub token_in_max_amount: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgSplitRouteSwapExactAmountOut {
    const NAME: &'static str = "MsgSplitRouteSwapExactAmountOut";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.MsgSplitRouteSwapExactAmountOut".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.MsgSplitRouteSwapExactAmountOut".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgSplitRouteSwapExactAmountOutResponse {
    #[prost(string, tag = "1")]
    pub token_in_amount: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgSplitRouteSwapExactAmountOutResponse {
    const NAME: &'static str = "MsgSplitRouteSwapExactAmountOutResponse";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.MsgSplitRouteSwapExactAmountOutResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.MsgSplitRouteSwapExactAmountOutResponse".into()
    }
}
/// ===================== MsgSetDenomPairTakerFee
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgSetDenomPairTakerFee {
    #[prost(string, tag = "1")]
    pub sender: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub denom_pair_taker_fee: ::prost::alloc::vec::Vec<DenomPairTakerFee>,
}
impl ::prost::Name for MsgSetDenomPairTakerFee {
    const NAME: &'static str = "MsgSetDenomPairTakerFee";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.MsgSetDenomPairTakerFee".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.MsgSetDenomPairTakerFee".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgSetDenomPairTakerFeeResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
}
impl ::prost::Name for MsgSetDenomPairTakerFeeResponse {
    const NAME: &'static str = "MsgSetDenomPairTakerFeeResponse";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.MsgSetDenomPairTakerFeeResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.MsgSetDenomPairTakerFeeResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DenomPairTakerFee {
    /// denom0 and denom1 get automatically lexigographically sorted
    /// when being stored, so the order of input here does not matter.
    #[prost(string, tag = "1")]
    pub denom0: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub denom1: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub taker_fee: ::prost::alloc::string::String,
}
impl ::prost::Name for DenomPairTakerFee {
    const NAME: &'static str = "DenomPairTakerFee";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.DenomPairTakerFee".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.DenomPairTakerFee".into()
    }
}
/// Generated client implementations.
#[cfg(feature = "osmosis")]
pub mod msg_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct MsgClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl MsgClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> MsgClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> MsgClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            MsgClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn swap_exact_amount_in(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgSwapExactAmountIn>,
        ) -> std::result::Result<
            tonic::Response<super::MsgSwapExactAmountInResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/osmosis.poolmanager.v1beta1.Msg/SwapExactAmountIn",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "osmosis.poolmanager.v1beta1.Msg",
                        "SwapExactAmountIn",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn swap_exact_amount_out(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgSwapExactAmountOut>,
        ) -> std::result::Result<
            tonic::Response<super::MsgSwapExactAmountOutResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/osmosis.poolmanager.v1beta1.Msg/SwapExactAmountOut",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "osmosis.poolmanager.v1beta1.Msg",
                        "SwapExactAmountOut",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn split_route_swap_exact_amount_in(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgSplitRouteSwapExactAmountIn>,
        ) -> std::result::Result<
            tonic::Response<super::MsgSplitRouteSwapExactAmountInResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/osmosis.poolmanager.v1beta1.Msg/SplitRouteSwapExactAmountIn",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "osmosis.poolmanager.v1beta1.Msg",
                        "SplitRouteSwapExactAmountIn",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn split_route_swap_exact_amount_out(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgSplitRouteSwapExactAmountOut>,
        ) -> std::result::Result<
            tonic::Response<super::MsgSplitRouteSwapExactAmountOutResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/osmosis.poolmanager.v1beta1.Msg/SplitRouteSwapExactAmountOut",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "osmosis.poolmanager.v1beta1.Msg",
                        "SplitRouteSwapExactAmountOut",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn set_denom_pair_taker_fee(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgSetDenomPairTakerFee>,
        ) -> std::result::Result<
            tonic::Response<super::MsgSetDenomPairTakerFeeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/osmosis.poolmanager.v1beta1.Msg/SetDenomPairTakerFee",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "osmosis.poolmanager.v1beta1.Msg",
                        "SetDenomPairTakerFee",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
#[cfg(feature = "osmosis")]
pub mod msg_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with MsgServer.
    #[async_trait]
    pub trait Msg: Send + Sync + 'static {
        async fn swap_exact_amount_in(
            &self,
            request: tonic::Request<super::MsgSwapExactAmountIn>,
        ) -> std::result::Result<
            tonic::Response<super::MsgSwapExactAmountInResponse>,
            tonic::Status,
        >;
        async fn swap_exact_amount_out(
            &self,
            request: tonic::Request<super::MsgSwapExactAmountOut>,
        ) -> std::result::Result<
            tonic::Response<super::MsgSwapExactAmountOutResponse>,
            tonic::Status,
        >;
        async fn split_route_swap_exact_amount_in(
            &self,
            request: tonic::Request<super::MsgSplitRouteSwapExactAmountIn>,
        ) -> std::result::Result<
            tonic::Response<super::MsgSplitRouteSwapExactAmountInResponse>,
            tonic::Status,
        >;
        async fn split_route_swap_exact_amount_out(
            &self,
            request: tonic::Request<super::MsgSplitRouteSwapExactAmountOut>,
        ) -> std::result::Result<
            tonic::Response<super::MsgSplitRouteSwapExactAmountOutResponse>,
            tonic::Status,
        >;
        async fn set_denom_pair_taker_fee(
            &self,
            request: tonic::Request<super::MsgSetDenomPairTakerFee>,
        ) -> std::result::Result<
            tonic::Response<super::MsgSetDenomPairTakerFeeResponse>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct MsgServer<T: Msg> {
        inner: _Inner<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    struct _Inner<T>(Arc<T>);
    impl<T: Msg> MsgServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            let inner = _Inner(inner);
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for MsgServer<T>
    where
        T: Msg,
        B: Body + Send + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/osmosis.poolmanager.v1beta1.Msg/SwapExactAmountIn" => {
                    #[allow(non_camel_case_types)]
                    struct SwapExactAmountInSvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg> tonic::server::UnaryService<super::MsgSwapExactAmountIn>
                    for SwapExactAmountInSvc<T> {
                        type Response = super::MsgSwapExactAmountInResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgSwapExactAmountIn>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Msg>::swap_exact_amount_in(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = SwapExactAmountInSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/osmosis.poolmanager.v1beta1.Msg/SwapExactAmountOut" => {
                    #[allow(non_camel_case_types)]
                    struct SwapExactAmountOutSvc<T: Msg>(pub Arc<T>);
                    impl<
                        T: Msg,
                    > tonic::server::UnaryService<super::MsgSwapExactAmountOut>
                    for SwapExactAmountOutSvc<T> {
                        type Response = super::MsgSwapExactAmountOutResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgSwapExactAmountOut>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Msg>::swap_exact_amount_out(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = SwapExactAmountOutSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/osmosis.poolmanager.v1beta1.Msg/SplitRouteSwapExactAmountIn" => {
                    #[allow(non_camel_case_types)]
                    struct SplitRouteSwapExactAmountInSvc<T: Msg>(pub Arc<T>);
                    impl<
                        T: Msg,
                    > tonic::server::UnaryService<super::MsgSplitRouteSwapExactAmountIn>
                    for SplitRouteSwapExactAmountInSvc<T> {
                        type Response = super::MsgSplitRouteSwapExactAmountInResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::MsgSplitRouteSwapExactAmountIn,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Msg>::split_route_swap_exact_amount_in(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = SplitRouteSwapExactAmountInSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/osmosis.poolmanager.v1beta1.Msg/SplitRouteSwapExactAmountOut" => {
                    #[allow(non_camel_case_types)]
                    struct SplitRouteSwapExactAmountOutSvc<T: Msg>(pub Arc<T>);
                    impl<
                        T: Msg,
                    > tonic::server::UnaryService<super::MsgSplitRouteSwapExactAmountOut>
                    for SplitRouteSwapExactAmountOutSvc<T> {
                        type Response = super::MsgSplitRouteSwapExactAmountOutResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::MsgSplitRouteSwapExactAmountOut,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Msg>::split_route_swap_exact_amount_out(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = SplitRouteSwapExactAmountOutSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/osmosis.poolmanager.v1beta1.Msg/SetDenomPairTakerFee" => {
                    #[allow(non_camel_case_types)]
                    struct SetDenomPairTakerFeeSvc<T: Msg>(pub Arc<T>);
                    impl<
                        T: Msg,
                    > tonic::server::UnaryService<super::MsgSetDenomPairTakerFee>
                    for SetDenomPairTakerFeeSvc<T> {
                        type Response = super::MsgSetDenomPairTakerFeeResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgSetDenomPairTakerFee>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Msg>::set_denom_pair_taker_fee(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = SetDenomPairTakerFeeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        Ok(
                            http::Response::builder()
                                .status(200)
                                .header("grpc-status", "12")
                                .header("content-type", "application/grpc")
                                .body(empty_body())
                                .unwrap(),
                        )
                    })
                }
            }
        }
    }
    impl<T: Msg> Clone for MsgServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    impl<T: Msg> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(Arc::clone(&self.0))
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: Msg> tonic::server::NamedService for MsgServer<T> {
        const NAME: &'static str = "osmosis.poolmanager.v1beta1.Msg";
    }
}
/// Params holds parameters for the poolmanager module
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Params {
    #[prost(message, repeated, tag = "1")]
    pub pool_creation_fee: ::prost::alloc::vec::Vec<
        super::super::super::cosmos::base::v1beta1::Coin,
    >,
    /// taker_fee_params is the container of taker fee parameters.
    #[prost(message, optional, tag = "2")]
    pub taker_fee_params: ::core::option::Option<TakerFeeParams>,
    /// authorized_quote_denoms is a list of quote denoms that can be used as
    /// token1 when creating a concentrated pool. We limit the quote assets to a
    /// small set for the purposes of having convenient price increments stemming
    /// from tick to price conversion. These increments are in a human readable
    /// magnitude only for token1 as a quote. For limit orders in the future, this
    /// will be a desirable property in terms of UX as to allow users to set limit
    /// orders at prices in terms of token1 (quote asset) that are easy to reason
    /// about.
    #[prost(string, repeated, tag = "3")]
    pub authorized_quote_denoms: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
impl ::prost::Name for Params {
    const NAME: &'static str = "Params";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.Params".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.Params".into()
    }
}
/// GenesisState defines the poolmanager module's genesis state.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenesisState {
    /// the next_pool_id
    #[prost(uint64, tag = "1")]
    pub next_pool_id: u64,
    /// params is the container of poolmanager parameters.
    #[prost(message, optional, tag = "2")]
    pub params: ::core::option::Option<Params>,
    /// pool_routes is the container of the mappings from pool id to pool type.
    #[prost(message, repeated, tag = "3")]
    pub pool_routes: ::prost::alloc::vec::Vec<ModuleRoute>,
    /// KVStore state
    #[prost(message, optional, tag = "4")]
    pub taker_fees_tracker: ::core::option::Option<TakerFeesTracker>,
    #[prost(message, repeated, tag = "5")]
    pub pool_volumes: ::prost::alloc::vec::Vec<PoolVolume>,
    #[prost(message, repeated, tag = "6")]
    pub denom_pair_taker_fee_store: ::prost::alloc::vec::Vec<DenomPairTakerFee>,
}
impl ::prost::Name for GenesisState {
    const NAME: &'static str = "GenesisState";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.GenesisState".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.GenesisState".into()
    }
}
/// TakerFeeParams consolidates the taker fee parameters for the poolmanager.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TakerFeeParams {
    /// default_taker_fee is the fee used when creating a new pool that doesn't
    /// fall under a custom pool taker fee or stableswap taker fee category.
    #[prost(string, tag = "1")]
    pub default_taker_fee: ::prost::alloc::string::String,
    /// osmo_taker_fee_distribution defines the distribution of taker fees
    /// generated in OSMO. As of this writing, it has two categories:
    /// - staking_rewards: the percent of the taker fee that gets distributed to
    ///    stakers.
    /// - community_pool: the percent of the taker fee that gets sent to the
    ///    community pool.
    #[prost(message, optional, tag = "2")]
    pub osmo_taker_fee_distribution: ::core::option::Option<
        TakerFeeDistributionPercentage,
    >,
    /// non_osmo_taker_fee_distribution defines the distribution of taker fees
    /// generated in non-OSMO. As of this writing, it has two categories:
    /// - staking_rewards: the percent of the taker fee that gets swapped to OSMO
    ///    and then distributed to stakers.
    /// - community_pool: the percent of the taker fee that gets sent to the
    ///    community pool. Note: If the non-OSMO asset is an authorized_quote_denom,
    ///    that denom is sent directly to the community pool. Otherwise, it is
    ///    swapped to the community_pool_denom_to_swap_non_whitelisted_assets_to and
    ///    then sent to the community pool as that denom.
    #[prost(message, optional, tag = "3")]
    pub non_osmo_taker_fee_distribution: ::core::option::Option<
        TakerFeeDistributionPercentage,
    >,
    /// admin_addresses is a list of addresses that are allowed to set and remove
    /// custom taker fees for denom pairs. Governance also has the ability to set
    /// and remove custom taker fees for denom pairs, but with the normal
    /// governance delay.
    #[prost(string, repeated, tag = "4")]
    pub admin_addresses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// community_pool_denom_to_swap_non_whitelisted_assets_to is the denom that
    /// non-whitelisted taker fees will be swapped to before being sent to
    /// the community pool.
    #[prost(string, tag = "5")]
    pub community_pool_denom_to_swap_non_whitelisted_assets_to: ::prost::alloc::string::String,
    /// reduced_fee_whitelist is a list of addresses that are
    /// allowed to pay a reduce taker fee when performing a swap
    /// (i.e. swap without paying the taker fee).
    /// It is intended to be used for integrators who meet qualifying factors
    /// that are approved by governance.
    /// Initially, the taker fee is allowed to be bypassed completely. However
    /// In the future, we will charge a reduced taker fee instead of no fee at all.
    #[prost(string, repeated, tag = "6")]
    pub reduced_fee_whitelist: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for TakerFeeParams {
    const NAME: &'static str = "TakerFeeParams";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.TakerFeeParams".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.TakerFeeParams".into()
    }
}
/// TakerFeeDistributionPercentage defines what percent of the taker fee category
/// gets distributed to the available categories.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TakerFeeDistributionPercentage {
    #[prost(string, tag = "1")]
    pub staking_rewards: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub community_pool: ::prost::alloc::string::String,
}
impl ::prost::Name for TakerFeeDistributionPercentage {
    const NAME: &'static str = "TakerFeeDistributionPercentage";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.TakerFeeDistributionPercentage".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.TakerFeeDistributionPercentage".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TakerFeesTracker {
    #[prost(message, repeated, tag = "1")]
    pub taker_fees_to_stakers: ::prost::alloc::vec::Vec<
        super::super::super::cosmos::base::v1beta1::Coin,
    >,
    #[prost(message, repeated, tag = "2")]
    pub taker_fees_to_community_pool: ::prost::alloc::vec::Vec<
        super::super::super::cosmos::base::v1beta1::Coin,
    >,
    #[prost(int64, tag = "3")]
    pub height_accounting_starts_from: i64,
}
impl ::prost::Name for TakerFeesTracker {
    const NAME: &'static str = "TakerFeesTracker";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.TakerFeesTracker".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.TakerFeesTracker".into()
    }
}
/// PoolVolume stores the KVStore entries for each pool's volume, which
/// is used in export/import genesis.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PoolVolume {
    /// pool_id is the id of the pool.
    #[prost(uint64, tag = "1")]
    pub pool_id: u64,
    /// pool_volume is the cumulative volume of the pool.
    #[prost(message, repeated, tag = "2")]
    pub pool_volume: ::prost::alloc::vec::Vec<
        super::super::super::cosmos::base::v1beta1::Coin,
    >,
}
impl ::prost::Name for PoolVolume {
    const NAME: &'static str = "PoolVolume";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.PoolVolume".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.PoolVolume".into()
    }
}
/// =============================== Params
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParamsRequest {}
impl ::prost::Name for ParamsRequest {
    const NAME: &'static str = "ParamsRequest";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.ParamsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.ParamsRequest".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParamsResponse {
    #[prost(message, optional, tag = "1")]
    pub params: ::core::option::Option<Params>,
}
impl ::prost::Name for ParamsResponse {
    const NAME: &'static str = "ParamsResponse";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.ParamsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.ParamsResponse".into()
    }
}
/// =============================== EstimateSwapExactAmountIn
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EstimateSwapExactAmountInRequest {
    #[deprecated]
    #[prost(uint64, tag = "2")]
    pub pool_id: u64,
    #[prost(string, tag = "3")]
    pub token_in: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "4")]
    pub routes: ::prost::alloc::vec::Vec<SwapAmountInRoute>,
}
impl ::prost::Name for EstimateSwapExactAmountInRequest {
    const NAME: &'static str = "EstimateSwapExactAmountInRequest";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.EstimateSwapExactAmountInRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.EstimateSwapExactAmountInRequest".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EstimateSwapExactAmountInWithPrimitiveTypesRequest {
    #[deprecated]
    #[prost(uint64, tag = "1")]
    pub pool_id: u64,
    #[prost(string, tag = "2")]
    pub token_in: ::prost::alloc::string::String,
    #[prost(uint64, repeated, packed = "false", tag = "3")]
    pub routes_pool_id: ::prost::alloc::vec::Vec<u64>,
    #[prost(string, repeated, tag = "4")]
    pub routes_token_out_denom: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for EstimateSwapExactAmountInWithPrimitiveTypesRequest {
    const NAME: &'static str = "EstimateSwapExactAmountInWithPrimitiveTypesRequest";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.EstimateSwapExactAmountInWithPrimitiveTypesRequest"
            .into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.EstimateSwapExactAmountInWithPrimitiveTypesRequest"
            .into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EstimateSinglePoolSwapExactAmountInRequest {
    #[prost(uint64, tag = "1")]
    pub pool_id: u64,
    #[prost(string, tag = "2")]
    pub token_in: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub token_out_denom: ::prost::alloc::string::String,
}
impl ::prost::Name for EstimateSinglePoolSwapExactAmountInRequest {
    const NAME: &'static str = "EstimateSinglePoolSwapExactAmountInRequest";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.EstimateSinglePoolSwapExactAmountInRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.EstimateSinglePoolSwapExactAmountInRequest".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EstimateSwapExactAmountInResponse {
    #[prost(string, tag = "1")]
    pub token_out_amount: ::prost::alloc::string::String,
}
impl ::prost::Name for EstimateSwapExactAmountInResponse {
    const NAME: &'static str = "EstimateSwapExactAmountInResponse";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.EstimateSwapExactAmountInResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.EstimateSwapExactAmountInResponse".into()
    }
}
/// =============================== EstimateSwapExactAmountOut
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EstimateSwapExactAmountOutRequest {
    #[deprecated]
    #[prost(uint64, tag = "2")]
    pub pool_id: u64,
    #[prost(message, repeated, tag = "3")]
    pub routes: ::prost::alloc::vec::Vec<SwapAmountOutRoute>,
    #[prost(string, tag = "4")]
    pub token_out: ::prost::alloc::string::String,
}
impl ::prost::Name for EstimateSwapExactAmountOutRequest {
    const NAME: &'static str = "EstimateSwapExactAmountOutRequest";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.EstimateSwapExactAmountOutRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.EstimateSwapExactAmountOutRequest".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EstimateSwapExactAmountOutWithPrimitiveTypesRequest {
    #[deprecated]
    #[prost(uint64, tag = "1")]
    pub pool_id: u64,
    #[prost(uint64, repeated, packed = "false", tag = "2")]
    pub routes_pool_id: ::prost::alloc::vec::Vec<u64>,
    #[prost(string, repeated, tag = "3")]
    pub routes_token_in_denom: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "4")]
    pub token_out: ::prost::alloc::string::String,
}
impl ::prost::Name for EstimateSwapExactAmountOutWithPrimitiveTypesRequest {
    const NAME: &'static str = "EstimateSwapExactAmountOutWithPrimitiveTypesRequest";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.EstimateSwapExactAmountOutWithPrimitiveTypesRequest"
            .into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.EstimateSwapExactAmountOutWithPrimitiveTypesRequest"
            .into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EstimateSinglePoolSwapExactAmountOutRequest {
    #[prost(uint64, tag = "1")]
    pub pool_id: u64,
    #[prost(string, tag = "2")]
    pub token_in_denom: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub token_out: ::prost::alloc::string::String,
}
impl ::prost::Name for EstimateSinglePoolSwapExactAmountOutRequest {
    const NAME: &'static str = "EstimateSinglePoolSwapExactAmountOutRequest";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.EstimateSinglePoolSwapExactAmountOutRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.EstimateSinglePoolSwapExactAmountOutRequest".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EstimateSwapExactAmountOutResponse {
    #[prost(string, tag = "1")]
    pub token_in_amount: ::prost::alloc::string::String,
}
impl ::prost::Name for EstimateSwapExactAmountOutResponse {
    const NAME: &'static str = "EstimateSwapExactAmountOutResponse";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.EstimateSwapExactAmountOutResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.EstimateSwapExactAmountOutResponse".into()
    }
}
/// =============================== NumPools
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NumPoolsRequest {}
impl ::prost::Name for NumPoolsRequest {
    const NAME: &'static str = "NumPoolsRequest";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.NumPoolsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.NumPoolsRequest".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NumPoolsResponse {
    #[prost(uint64, tag = "1")]
    pub num_pools: u64,
}
impl ::prost::Name for NumPoolsResponse {
    const NAME: &'static str = "NumPoolsResponse";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.NumPoolsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.NumPoolsResponse".into()
    }
}
/// =============================== Pool
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PoolRequest {
    #[prost(uint64, tag = "1")]
    pub pool_id: u64,
}
impl ::prost::Name for PoolRequest {
    const NAME: &'static str = "PoolRequest";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.PoolRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.PoolRequest".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PoolResponse {
    #[prost(message, optional, tag = "1")]
    pub pool: ::core::option::Option<::prost_types::Any>,
}
impl ::prost::Name for PoolResponse {
    const NAME: &'static str = "PoolResponse";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.PoolResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.PoolResponse".into()
    }
}
/// =============================== AllPools
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AllPoolsRequest {}
impl ::prost::Name for AllPoolsRequest {
    const NAME: &'static str = "AllPoolsRequest";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.AllPoolsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.AllPoolsRequest".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AllPoolsResponse {
    #[prost(message, repeated, tag = "1")]
    pub pools: ::prost::alloc::vec::Vec<::prost_types::Any>,
}
impl ::prost::Name for AllPoolsResponse {
    const NAME: &'static str = "AllPoolsResponse";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.AllPoolsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.AllPoolsResponse".into()
    }
}
/// =======================================================
/// ListPoolsByDenomRequest
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPoolsByDenomRequest {
    #[prost(string, tag = "1")]
    pub denom: ::prost::alloc::string::String,
}
impl ::prost::Name for ListPoolsByDenomRequest {
    const NAME: &'static str = "ListPoolsByDenomRequest";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.ListPoolsByDenomRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.ListPoolsByDenomRequest".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPoolsByDenomResponse {
    #[prost(message, repeated, tag = "1")]
    pub pools: ::prost::alloc::vec::Vec<::prost_types::Any>,
}
impl ::prost::Name for ListPoolsByDenomResponse {
    const NAME: &'static str = "ListPoolsByDenomResponse";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.ListPoolsByDenomResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.ListPoolsByDenomResponse".into()
    }
}
/// ==========================================================
/// SpotPriceRequest defines the gRPC request structure for a SpotPrice
/// query.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpotPriceRequest {
    #[prost(uint64, tag = "1")]
    pub pool_id: u64,
    #[prost(string, tag = "2")]
    pub base_asset_denom: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub quote_asset_denom: ::prost::alloc::string::String,
}
impl ::prost::Name for SpotPriceRequest {
    const NAME: &'static str = "SpotPriceRequest";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.SpotPriceRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.SpotPriceRequest".into()
    }
}
/// SpotPriceResponse defines the gRPC response structure for a SpotPrice
/// query.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpotPriceResponse {
    /// String of the Dec. Ex) 10.203uatom
    #[prost(string, tag = "1")]
    pub spot_price: ::prost::alloc::string::String,
}
impl ::prost::Name for SpotPriceResponse {
    const NAME: &'static str = "SpotPriceResponse";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.SpotPriceResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.SpotPriceResponse".into()
    }
}
/// =============================== TotalPoolLiquidity
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TotalPoolLiquidityRequest {
    #[prost(uint64, tag = "1")]
    pub pool_id: u64,
}
impl ::prost::Name for TotalPoolLiquidityRequest {
    const NAME: &'static str = "TotalPoolLiquidityRequest";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.TotalPoolLiquidityRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.TotalPoolLiquidityRequest".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TotalPoolLiquidityResponse {
    #[prost(message, repeated, tag = "1")]
    pub liquidity: ::prost::alloc::vec::Vec<
        super::super::super::cosmos::base::v1beta1::Coin,
    >,
}
impl ::prost::Name for TotalPoolLiquidityResponse {
    const NAME: &'static str = "TotalPoolLiquidityResponse";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.TotalPoolLiquidityResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.TotalPoolLiquidityResponse".into()
    }
}
/// =============================== TotalLiquidity
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TotalLiquidityRequest {}
impl ::prost::Name for TotalLiquidityRequest {
    const NAME: &'static str = "TotalLiquidityRequest";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.TotalLiquidityRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.TotalLiquidityRequest".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TotalLiquidityResponse {
    #[prost(message, repeated, tag = "1")]
    pub liquidity: ::prost::alloc::vec::Vec<
        super::super::super::cosmos::base::v1beta1::Coin,
    >,
}
impl ::prost::Name for TotalLiquidityResponse {
    const NAME: &'static str = "TotalLiquidityResponse";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.TotalLiquidityResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.TotalLiquidityResponse".into()
    }
}
/// =============================== TotalVolumeForPool
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TotalVolumeForPoolRequest {
    #[prost(uint64, tag = "1")]
    pub pool_id: u64,
}
impl ::prost::Name for TotalVolumeForPoolRequest {
    const NAME: &'static str = "TotalVolumeForPoolRequest";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.TotalVolumeForPoolRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.TotalVolumeForPoolRequest".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TotalVolumeForPoolResponse {
    #[prost(message, repeated, tag = "1")]
    pub volume: ::prost::alloc::vec::Vec<
        super::super::super::cosmos::base::v1beta1::Coin,
    >,
}
impl ::prost::Name for TotalVolumeForPoolResponse {
    const NAME: &'static str = "TotalVolumeForPoolResponse";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.TotalVolumeForPoolResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.TotalVolumeForPoolResponse".into()
    }
}
/// =============================== TradingPairTakerFee
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TradingPairTakerFeeRequest {
    #[prost(string, tag = "1")]
    pub denom_0: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub denom_1: ::prost::alloc::string::String,
}
impl ::prost::Name for TradingPairTakerFeeRequest {
    const NAME: &'static str = "TradingPairTakerFeeRequest";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.TradingPairTakerFeeRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.TradingPairTakerFeeRequest".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TradingPairTakerFeeResponse {
    #[prost(string, tag = "1")]
    pub taker_fee: ::prost::alloc::string::String,
}
impl ::prost::Name for TradingPairTakerFeeResponse {
    const NAME: &'static str = "TradingPairTakerFeeResponse";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.TradingPairTakerFeeResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.TradingPairTakerFeeResponse".into()
    }
}
/// EstimateTradeBasedOnPriceImpactRequest represents a request to estimate a
/// trade for Balancer/StableSwap/Concentrated liquidity pool types based on the
/// given parameters.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EstimateTradeBasedOnPriceImpactRequest {
    /// from_coin is the total amount of tokens that the user wants to sell.
    #[prost(message, optional, tag = "1")]
    pub from_coin: ::core::option::Option<
        super::super::super::cosmos::base::v1beta1::Coin,
    >,
    /// to_coin_denom is the denom identifier of the token that the user wants to
    /// buy.
    #[prost(string, tag = "2")]
    pub to_coin_denom: ::prost::alloc::string::String,
    /// pool_id is the identifier of the liquidity pool that the trade will occur
    /// on.
    #[prost(uint64, tag = "3")]
    pub pool_id: u64,
    /// max_price_impact is the maximum percentage that the user is willing
    /// to affect the price of the liquidity pool.
    #[prost(string, tag = "4")]
    pub max_price_impact: ::prost::alloc::string::String,
    /// external_price is an optional external price that the user can enter.
    /// It adjusts the MaxPriceImpact as the SpotPrice of a pool can be changed at
    /// any time.
    #[prost(string, tag = "5")]
    pub external_price: ::prost::alloc::string::String,
}
impl ::prost::Name for EstimateTradeBasedOnPriceImpactRequest {
    const NAME: &'static str = "EstimateTradeBasedOnPriceImpactRequest";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.EstimateTradeBasedOnPriceImpactRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.EstimateTradeBasedOnPriceImpactRequest".into()
    }
}
/// EstimateTradeBasedOnPriceImpactResponse represents the response data
/// for an estimated trade based on price impact. If a trade fails to be
/// estimated the response would be 0,0 for input_coin and output_coin and will
/// not error.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EstimateTradeBasedOnPriceImpactResponse {
    /// input_coin is the actual input amount that would be tradeable
    /// under the specified price impact.
    #[prost(message, optional, tag = "1")]
    pub input_coin: ::core::option::Option<
        super::super::super::cosmos::base::v1beta1::Coin,
    >,
    /// output_coin is the amount of tokens of the ToCoinDenom type
    /// that will be received for the actual InputCoin trade.
    #[prost(message, optional, tag = "2")]
    pub output_coin: ::core::option::Option<
        super::super::super::cosmos::base::v1beta1::Coin,
    >,
}
impl ::prost::Name for EstimateTradeBasedOnPriceImpactResponse {
    const NAME: &'static str = "EstimateTradeBasedOnPriceImpactResponse";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.EstimateTradeBasedOnPriceImpactResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.EstimateTradeBasedOnPriceImpactResponse".into()
    }
}
/// Generated client implementations.
#[cfg(feature = "osmosis")]
pub mod query_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct QueryClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl QueryClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> QueryClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> QueryClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            QueryClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn params(
            &mut self,
            request: impl tonic::IntoRequest<super::ParamsRequest>,
        ) -> std::result::Result<tonic::Response<super::ParamsResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/osmosis.poolmanager.v1beta1.Query/Params",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("osmosis.poolmanager.v1beta1.Query", "Params"));
            self.inner.unary(req, path, codec).await
        }
        /// Estimates swap amount out given in.
        pub async fn estimate_swap_exact_amount_in(
            &mut self,
            request: impl tonic::IntoRequest<super::EstimateSwapExactAmountInRequest>,
        ) -> std::result::Result<
            tonic::Response<super::EstimateSwapExactAmountInResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/osmosis.poolmanager.v1beta1.Query/EstimateSwapExactAmountIn",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "osmosis.poolmanager.v1beta1.Query",
                        "EstimateSwapExactAmountIn",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// EstimateSwapExactAmountInWithPrimitiveTypes is an alternative query for
        /// EstimateSwapExactAmountIn. Supports query via GRPC-Gateway by using
        /// primitive types instead of repeated structs. Each index in the
        /// routes_pool_id field corresponds to the respective routes_token_out_denom
        /// value, thus they are required to have the same length and are grouped
        /// together as pairs.
        /// example usage:
        /// http://0.0.0.0:1317/osmosis/poolmanager/v1beta1/1/estimate/
        /// swap_exact_amount_in_with_primitive_types?token_in=100000stake&routes_token_out_denom=uatom
        /// &routes_token_out_denom=uion&routes_pool_id=1&routes_pool_id=2
        pub async fn estimate_swap_exact_amount_in_with_primitive_types(
            &mut self,
            request: impl tonic::IntoRequest<
                super::EstimateSwapExactAmountInWithPrimitiveTypesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::EstimateSwapExactAmountInResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/osmosis.poolmanager.v1beta1.Query/EstimateSwapExactAmountInWithPrimitiveTypes",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "osmosis.poolmanager.v1beta1.Query",
                        "EstimateSwapExactAmountInWithPrimitiveTypes",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn estimate_single_pool_swap_exact_amount_in(
            &mut self,
            request: impl tonic::IntoRequest<
                super::EstimateSinglePoolSwapExactAmountInRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::EstimateSwapExactAmountInResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/osmosis.poolmanager.v1beta1.Query/EstimateSinglePoolSwapExactAmountIn",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "osmosis.poolmanager.v1beta1.Query",
                        "EstimateSinglePoolSwapExactAmountIn",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Estimates swap amount in given out.
        pub async fn estimate_swap_exact_amount_out(
            &mut self,
            request: impl tonic::IntoRequest<super::EstimateSwapExactAmountOutRequest>,
        ) -> std::result::Result<
            tonic::Response<super::EstimateSwapExactAmountOutResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/osmosis.poolmanager.v1beta1.Query/EstimateSwapExactAmountOut",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "osmosis.poolmanager.v1beta1.Query",
                        "EstimateSwapExactAmountOut",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Estimates swap amount in given out.
        pub async fn estimate_swap_exact_amount_out_with_primitive_types(
            &mut self,
            request: impl tonic::IntoRequest<
                super::EstimateSwapExactAmountOutWithPrimitiveTypesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::EstimateSwapExactAmountOutResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/osmosis.poolmanager.v1beta1.Query/EstimateSwapExactAmountOutWithPrimitiveTypes",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "osmosis.poolmanager.v1beta1.Query",
                        "EstimateSwapExactAmountOutWithPrimitiveTypes",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn estimate_single_pool_swap_exact_amount_out(
            &mut self,
            request: impl tonic::IntoRequest<
                super::EstimateSinglePoolSwapExactAmountOutRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::EstimateSwapExactAmountOutResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/osmosis.poolmanager.v1beta1.Query/EstimateSinglePoolSwapExactAmountOut",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "osmosis.poolmanager.v1beta1.Query",
                        "EstimateSinglePoolSwapExactAmountOut",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the total number of pools existing in Osmosis.
        pub async fn num_pools(
            &mut self,
            request: impl tonic::IntoRequest<super::NumPoolsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::NumPoolsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/osmosis.poolmanager.v1beta1.Query/NumPools",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("osmosis.poolmanager.v1beta1.Query", "NumPools"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Pool returns the Pool specified by the pool id
        pub async fn pool(
            &mut self,
            request: impl tonic::IntoRequest<super::PoolRequest>,
        ) -> std::result::Result<tonic::Response<super::PoolResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/osmosis.poolmanager.v1beta1.Query/Pool",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("osmosis.poolmanager.v1beta1.Query", "Pool"));
            self.inner.unary(req, path, codec).await
        }
        /// AllPools returns all pools on the Osmosis chain sorted by IDs.
        pub async fn all_pools(
            &mut self,
            request: impl tonic::IntoRequest<super::AllPoolsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AllPoolsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/osmosis.poolmanager.v1beta1.Query/AllPools",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("osmosis.poolmanager.v1beta1.Query", "AllPools"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// ListPoolsByDenom return all pools by denom
        pub async fn list_pools_by_denom(
            &mut self,
            request: impl tonic::IntoRequest<super::ListPoolsByDenomRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListPoolsByDenomResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/osmosis.poolmanager.v1beta1.Query/ListPoolsByDenom",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "osmosis.poolmanager.v1beta1.Query",
                        "ListPoolsByDenom",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// SpotPrice defines a gRPC query handler that returns the spot price given
        /// a base denomination and a quote denomination.
        pub async fn spot_price(
            &mut self,
            request: impl tonic::IntoRequest<super::SpotPriceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SpotPriceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/osmosis.poolmanager.v1beta1.Query/SpotPrice",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("osmosis.poolmanager.v1beta1.Query", "SpotPrice"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// TotalPoolLiquidity returns the total liquidity of the specified pool.
        pub async fn total_pool_liquidity(
            &mut self,
            request: impl tonic::IntoRequest<super::TotalPoolLiquidityRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TotalPoolLiquidityResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/osmosis.poolmanager.v1beta1.Query/TotalPoolLiquidity",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "osmosis.poolmanager.v1beta1.Query",
                        "TotalPoolLiquidity",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// TotalLiquidity returns the total liquidity across all pools.
        pub async fn total_liquidity(
            &mut self,
            request: impl tonic::IntoRequest<super::TotalLiquidityRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TotalLiquidityResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/osmosis.poolmanager.v1beta1.Query/TotalLiquidity",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "osmosis.poolmanager.v1beta1.Query",
                        "TotalLiquidity",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// TotalVolumeForPool returns the total volume of the specified pool.
        pub async fn total_volume_for_pool(
            &mut self,
            request: impl tonic::IntoRequest<super::TotalVolumeForPoolRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TotalVolumeForPoolResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/osmosis.poolmanager.v1beta1.Query/TotalVolumeForPool",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "osmosis.poolmanager.v1beta1.Query",
                        "TotalVolumeForPool",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// TradingPairTakerFee returns the taker fee for a given set of denoms
        pub async fn trading_pair_taker_fee(
            &mut self,
            request: impl tonic::IntoRequest<super::TradingPairTakerFeeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TradingPairTakerFeeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/osmosis.poolmanager.v1beta1.Query/TradingPairTakerFee",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "osmosis.poolmanager.v1beta1.Query",
                        "TradingPairTakerFee",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// EstimateTradeBasedOnPriceImpact returns an estimated trade based on price
        /// impact, if a trade cannot be estimated a 0 input and 0 output would be
        /// returned.
        pub async fn estimate_trade_based_on_price_impact(
            &mut self,
            request: impl tonic::IntoRequest<
                super::EstimateTradeBasedOnPriceImpactRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::EstimateTradeBasedOnPriceImpactResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/osmosis.poolmanager.v1beta1.Query/EstimateTradeBasedOnPriceImpact",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "osmosis.poolmanager.v1beta1.Query",
                        "EstimateTradeBasedOnPriceImpact",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
#[cfg(feature = "osmosis")]
pub mod query_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with QueryServer.
    #[async_trait]
    pub trait Query: Send + Sync + 'static {
        async fn params(
            &self,
            request: tonic::Request<super::ParamsRequest>,
        ) -> std::result::Result<tonic::Response<super::ParamsResponse>, tonic::Status>;
        /// Estimates swap amount out given in.
        async fn estimate_swap_exact_amount_in(
            &self,
            request: tonic::Request<super::EstimateSwapExactAmountInRequest>,
        ) -> std::result::Result<
            tonic::Response<super::EstimateSwapExactAmountInResponse>,
            tonic::Status,
        >;
        /// EstimateSwapExactAmountInWithPrimitiveTypes is an alternative query for
        /// EstimateSwapExactAmountIn. Supports query via GRPC-Gateway by using
        /// primitive types instead of repeated structs. Each index in the
        /// routes_pool_id field corresponds to the respective routes_token_out_denom
        /// value, thus they are required to have the same length and are grouped
        /// together as pairs.
        /// example usage:
        /// http://0.0.0.0:1317/osmosis/poolmanager/v1beta1/1/estimate/
        /// swap_exact_amount_in_with_primitive_types?token_in=100000stake&routes_token_out_denom=uatom
        /// &routes_token_out_denom=uion&routes_pool_id=1&routes_pool_id=2
        async fn estimate_swap_exact_amount_in_with_primitive_types(
            &self,
            request: tonic::Request<
                super::EstimateSwapExactAmountInWithPrimitiveTypesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::EstimateSwapExactAmountInResponse>,
            tonic::Status,
        >;
        async fn estimate_single_pool_swap_exact_amount_in(
            &self,
            request: tonic::Request<super::EstimateSinglePoolSwapExactAmountInRequest>,
        ) -> std::result::Result<
            tonic::Response<super::EstimateSwapExactAmountInResponse>,
            tonic::Status,
        >;
        /// Estimates swap amount in given out.
        async fn estimate_swap_exact_amount_out(
            &self,
            request: tonic::Request<super::EstimateSwapExactAmountOutRequest>,
        ) -> std::result::Result<
            tonic::Response<super::EstimateSwapExactAmountOutResponse>,
            tonic::Status,
        >;
        /// Estimates swap amount in given out.
        async fn estimate_swap_exact_amount_out_with_primitive_types(
            &self,
            request: tonic::Request<
                super::EstimateSwapExactAmountOutWithPrimitiveTypesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::EstimateSwapExactAmountOutResponse>,
            tonic::Status,
        >;
        async fn estimate_single_pool_swap_exact_amount_out(
            &self,
            request: tonic::Request<super::EstimateSinglePoolSwapExactAmountOutRequest>,
        ) -> std::result::Result<
            tonic::Response<super::EstimateSwapExactAmountOutResponse>,
            tonic::Status,
        >;
        /// Returns the total number of pools existing in Osmosis.
        async fn num_pools(
            &self,
            request: tonic::Request<super::NumPoolsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::NumPoolsResponse>,
            tonic::Status,
        >;
        /// Pool returns the Pool specified by the pool id
        async fn pool(
            &self,
            request: tonic::Request<super::PoolRequest>,
        ) -> std::result::Result<tonic::Response<super::PoolResponse>, tonic::Status>;
        /// AllPools returns all pools on the Osmosis chain sorted by IDs.
        async fn all_pools(
            &self,
            request: tonic::Request<super::AllPoolsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AllPoolsResponse>,
            tonic::Status,
        >;
        /// ListPoolsByDenom return all pools by denom
        async fn list_pools_by_denom(
            &self,
            request: tonic::Request<super::ListPoolsByDenomRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListPoolsByDenomResponse>,
            tonic::Status,
        >;
        /// SpotPrice defines a gRPC query handler that returns the spot price given
        /// a base denomination and a quote denomination.
        async fn spot_price(
            &self,
            request: tonic::Request<super::SpotPriceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SpotPriceResponse>,
            tonic::Status,
        >;
        /// TotalPoolLiquidity returns the total liquidity of the specified pool.
        async fn total_pool_liquidity(
            &self,
            request: tonic::Request<super::TotalPoolLiquidityRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TotalPoolLiquidityResponse>,
            tonic::Status,
        >;
        /// TotalLiquidity returns the total liquidity across all pools.
        async fn total_liquidity(
            &self,
            request: tonic::Request<super::TotalLiquidityRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TotalLiquidityResponse>,
            tonic::Status,
        >;
        /// TotalVolumeForPool returns the total volume of the specified pool.
        async fn total_volume_for_pool(
            &self,
            request: tonic::Request<super::TotalVolumeForPoolRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TotalVolumeForPoolResponse>,
            tonic::Status,
        >;
        /// TradingPairTakerFee returns the taker fee for a given set of denoms
        async fn trading_pair_taker_fee(
            &self,
            request: tonic::Request<super::TradingPairTakerFeeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TradingPairTakerFeeResponse>,
            tonic::Status,
        >;
        /// EstimateTradeBasedOnPriceImpact returns an estimated trade based on price
        /// impact, if a trade cannot be estimated a 0 input and 0 output would be
        /// returned.
        async fn estimate_trade_based_on_price_impact(
            &self,
            request: tonic::Request<super::EstimateTradeBasedOnPriceImpactRequest>,
        ) -> std::result::Result<
            tonic::Response<super::EstimateTradeBasedOnPriceImpactResponse>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct QueryServer<T: Query> {
        inner: _Inner<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    struct _Inner<T>(Arc<T>);
    impl<T: Query> QueryServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            let inner = _Inner(inner);
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for QueryServer<T>
    where
        T: Query,
        B: Body + Send + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/osmosis.poolmanager.v1beta1.Query/Params" => {
                    #[allow(non_camel_case_types)]
                    struct ParamsSvc<T: Query>(pub Arc<T>);
                    impl<T: Query> tonic::server::UnaryService<super::ParamsRequest>
                    for ParamsSvc<T> {
                        type Response = super::ParamsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ParamsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::params(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ParamsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/osmosis.poolmanager.v1beta1.Query/EstimateSwapExactAmountIn" => {
                    #[allow(non_camel_case_types)]
                    struct EstimateSwapExactAmountInSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<
                        super::EstimateSwapExactAmountInRequest,
                    > for EstimateSwapExactAmountInSvc<T> {
                        type Response = super::EstimateSwapExactAmountInResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::EstimateSwapExactAmountInRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::estimate_swap_exact_amount_in(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = EstimateSwapExactAmountInSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/osmosis.poolmanager.v1beta1.Query/EstimateSwapExactAmountInWithPrimitiveTypes" => {
                    #[allow(non_camel_case_types)]
                    struct EstimateSwapExactAmountInWithPrimitiveTypesSvc<T: Query>(
                        pub Arc<T>,
                    );
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<
                        super::EstimateSwapExactAmountInWithPrimitiveTypesRequest,
                    > for EstimateSwapExactAmountInWithPrimitiveTypesSvc<T> {
                        type Response = super::EstimateSwapExactAmountInResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::EstimateSwapExactAmountInWithPrimitiveTypesRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::estimate_swap_exact_amount_in_with_primitive_types(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = EstimateSwapExactAmountInWithPrimitiveTypesSvc(
                            inner,
                        );
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/osmosis.poolmanager.v1beta1.Query/EstimateSinglePoolSwapExactAmountIn" => {
                    #[allow(non_camel_case_types)]
                    struct EstimateSinglePoolSwapExactAmountInSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<
                        super::EstimateSinglePoolSwapExactAmountInRequest,
                    > for EstimateSinglePoolSwapExactAmountInSvc<T> {
                        type Response = super::EstimateSwapExactAmountInResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::EstimateSinglePoolSwapExactAmountInRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::estimate_single_pool_swap_exact_amount_in(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = EstimateSinglePoolSwapExactAmountInSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/osmosis.poolmanager.v1beta1.Query/EstimateSwapExactAmountOut" => {
                    #[allow(non_camel_case_types)]
                    struct EstimateSwapExactAmountOutSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<
                        super::EstimateSwapExactAmountOutRequest,
                    > for EstimateSwapExactAmountOutSvc<T> {
                        type Response = super::EstimateSwapExactAmountOutResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::EstimateSwapExactAmountOutRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::estimate_swap_exact_amount_out(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = EstimateSwapExactAmountOutSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/osmosis.poolmanager.v1beta1.Query/EstimateSwapExactAmountOutWithPrimitiveTypes" => {
                    #[allow(non_camel_case_types)]
                    struct EstimateSwapExactAmountOutWithPrimitiveTypesSvc<T: Query>(
                        pub Arc<T>,
                    );
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<
                        super::EstimateSwapExactAmountOutWithPrimitiveTypesRequest,
                    > for EstimateSwapExactAmountOutWithPrimitiveTypesSvc<T> {
                        type Response = super::EstimateSwapExactAmountOutResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::EstimateSwapExactAmountOutWithPrimitiveTypesRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::estimate_swap_exact_amount_out_with_primitive_types(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = EstimateSwapExactAmountOutWithPrimitiveTypesSvc(
                            inner,
                        );
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/osmosis.poolmanager.v1beta1.Query/EstimateSinglePoolSwapExactAmountOut" => {
                    #[allow(non_camel_case_types)]
                    struct EstimateSinglePoolSwapExactAmountOutSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<
                        super::EstimateSinglePoolSwapExactAmountOutRequest,
                    > for EstimateSinglePoolSwapExactAmountOutSvc<T> {
                        type Response = super::EstimateSwapExactAmountOutResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::EstimateSinglePoolSwapExactAmountOutRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::estimate_single_pool_swap_exact_amount_out(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = EstimateSinglePoolSwapExactAmountOutSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/osmosis.poolmanager.v1beta1.Query/NumPools" => {
                    #[allow(non_camel_case_types)]
                    struct NumPoolsSvc<T: Query>(pub Arc<T>);
                    impl<T: Query> tonic::server::UnaryService<super::NumPoolsRequest>
                    for NumPoolsSvc<T> {
                        type Response = super::NumPoolsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::NumPoolsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::num_pools(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = NumPoolsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/osmosis.poolmanager.v1beta1.Query/Pool" => {
                    #[allow(non_camel_case_types)]
                    struct PoolSvc<T: Query>(pub Arc<T>);
                    impl<T: Query> tonic::server::UnaryService<super::PoolRequest>
                    for PoolSvc<T> {
                        type Response = super::PoolResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PoolRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::pool(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = PoolSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/osmosis.poolmanager.v1beta1.Query/AllPools" => {
                    #[allow(non_camel_case_types)]
                    struct AllPoolsSvc<T: Query>(pub Arc<T>);
                    impl<T: Query> tonic::server::UnaryService<super::AllPoolsRequest>
                    for AllPoolsSvc<T> {
                        type Response = super::AllPoolsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AllPoolsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::all_pools(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = AllPoolsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/osmosis.poolmanager.v1beta1.Query/ListPoolsByDenom" => {
                    #[allow(non_camel_case_types)]
                    struct ListPoolsByDenomSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<super::ListPoolsByDenomRequest>
                    for ListPoolsByDenomSvc<T> {
                        type Response = super::ListPoolsByDenomResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListPoolsByDenomRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::list_pools_by_denom(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ListPoolsByDenomSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/osmosis.poolmanager.v1beta1.Query/SpotPrice" => {
                    #[allow(non_camel_case_types)]
                    struct SpotPriceSvc<T: Query>(pub Arc<T>);
                    impl<T: Query> tonic::server::UnaryService<super::SpotPriceRequest>
                    for SpotPriceSvc<T> {
                        type Response = super::SpotPriceResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SpotPriceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::spot_price(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = SpotPriceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/osmosis.poolmanager.v1beta1.Query/TotalPoolLiquidity" => {
                    #[allow(non_camel_case_types)]
                    struct TotalPoolLiquiditySvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<super::TotalPoolLiquidityRequest>
                    for TotalPoolLiquiditySvc<T> {
                        type Response = super::TotalPoolLiquidityResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::TotalPoolLiquidityRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::total_pool_liquidity(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = TotalPoolLiquiditySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/osmosis.poolmanager.v1beta1.Query/TotalLiquidity" => {
                    #[allow(non_camel_case_types)]
                    struct TotalLiquiditySvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<super::TotalLiquidityRequest>
                    for TotalLiquiditySvc<T> {
                        type Response = super::TotalLiquidityResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::TotalLiquidityRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::total_liquidity(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = TotalLiquiditySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/osmosis.poolmanager.v1beta1.Query/TotalVolumeForPool" => {
                    #[allow(non_camel_case_types)]
                    struct TotalVolumeForPoolSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<super::TotalVolumeForPoolRequest>
                    for TotalVolumeForPoolSvc<T> {
                        type Response = super::TotalVolumeForPoolResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::TotalVolumeForPoolRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::total_volume_for_pool(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = TotalVolumeForPoolSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/osmosis.poolmanager.v1beta1.Query/TradingPairTakerFee" => {
                    #[allow(non_camel_case_types)]
                    struct TradingPairTakerFeeSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<super::TradingPairTakerFeeRequest>
                    for TradingPairTakerFeeSvc<T> {
                        type Response = super::TradingPairTakerFeeResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::TradingPairTakerFeeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::trading_pair_taker_fee(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = TradingPairTakerFeeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/osmosis.poolmanager.v1beta1.Query/EstimateTradeBasedOnPriceImpact" => {
                    #[allow(non_camel_case_types)]
                    struct EstimateTradeBasedOnPriceImpactSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<
                        super::EstimateTradeBasedOnPriceImpactRequest,
                    > for EstimateTradeBasedOnPriceImpactSvc<T> {
                        type Response = super::EstimateTradeBasedOnPriceImpactResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::EstimateTradeBasedOnPriceImpactRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::estimate_trade_based_on_price_impact(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = EstimateTradeBasedOnPriceImpactSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        Ok(
                            http::Response::builder()
                                .status(200)
                                .header("grpc-status", "12")
                                .header("content-type", "application/grpc")
                                .body(empty_body())
                                .unwrap(),
                        )
                    })
                }
            }
        }
    }
    impl<T: Query> Clone for QueryServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    impl<T: Query> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(Arc::clone(&self.0))
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: Query> tonic::server::NamedService for QueryServer<T> {
        const NAME: &'static str = "osmosis.poolmanager.v1beta1.Query";
    }
}
/// DenomPairTakerFeeProposal is a type for adding/removing a custom taker fee(s)
/// for one or more denom pairs.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DenomPairTakerFeeProposal {
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub denom_pair_taker_fee: ::prost::alloc::vec::Vec<DenomPairTakerFee>,
}
impl ::prost::Name for DenomPairTakerFeeProposal {
    const NAME: &'static str = "DenomPairTakerFeeProposal";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.DenomPairTakerFeeProposal".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.DenomPairTakerFeeProposal".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TrackedVolume {
    #[prost(message, repeated, tag = "1")]
    pub amount: ::prost::alloc::vec::Vec<
        super::super::super::cosmos::base::v1beta1::Coin,
    >,
}
impl ::prost::Name for TrackedVolume {
    const NAME: &'static str = "TrackedVolume";
    const PACKAGE: &'static str = "osmosis.poolmanager.v1beta1";
    fn full_name() -> ::prost::alloc::string::String {
        "osmosis.poolmanager.v1beta1.TrackedVolume".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/osmosis.poolmanager.v1beta1.TrackedVolume".into()
    }
}
